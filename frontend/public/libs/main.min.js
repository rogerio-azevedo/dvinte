'use strict'

function dice_initialize(container) {
  const id = id => {
    return document.getElementById(id)
  }

  const bind = (sel, eventname, func, bubble) => {
    if (!sel) return
    if (eventname.constructor === Array) {
      for (var i in eventname)
        sel.addEventListener(eventname[i], func, bubble ? bubble : false)
    } else sel.addEventListener(eventname, func, bubble ? bubble : false)
  }

  const canvas = id('canvas')
  canvas.style.width = window.innerWidth - 1 + 'px'
  canvas.style.height = window.innerHeight - 1 + 'px'

  bind(window, 'resize', function () {
    canvas.style.width = window.innerWidth - 1 + 'px'
    canvas.style.height = window.innerHeight - 1 + 'px'
    box.reinit(canvas, { w: 500, h: 300 })
  })

  const diceResult = id('dices')
  const set = id('set')
  on_set_change()

  function on_set_change(ev) {}
  bind(set, 'keyup', on_set_change)
  bind(set, 'mousedown', function (ev) {
    ev.stopPropagation()
  })
  bind(set, 'mouseup', function (ev) {
    ev.stopPropagation()
  })
  // $t.bind(set, 'focus', function (ev) {
  //   $t.set(container, { class: '' })
  // })
  // $t.bind(set, 'blur', function (ev) {
  //   $t.set(container, { class: 'noselect' })
  // })

  bind(id('clear'), ['mouseup', 'touchend'], function (ev) {
    ev.stopPropagation()
    set.value = '0'
    on_set_change()
  })

  var box = new $t.dice.dice_box(canvas, { w: 500, h: 300 })

  bind(window, 'resize', function () {
    canvas.style.width = window.innerWidth - 1 + 'px'
    canvas.style.height = window.innerHeight - 1 + 'px'
    box.reinit(canvas, { w: 500, h: 300 })
  })

  function before_roll(vectors, notation, callback) {
    // do here rpc call or whatever to get your own result of throw.
    // then callback with array of your result, example:
    // callback([2, 2, 2, 2]); // for 4d6 where all dice values are 2.
    callback()
  }

  const known_types = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20']

  const parse_notation = notation => {
    var no = notation.split('@')
    var dr0 = /\s*(\d*)([a-z]+)(\d+)(\s*(\+|\-)\s*(\d+)){0,1}\s*(\+|$)/gi
    var dr1 = /(\b)*(\d+)(\b)*/gi
    var ret = { set: [], constant: 0, result: [], error: false },
      res
    while ((res = dr0.exec(no[0]))) {
      var command = res[2]
      if (command != 'd') {
        ret.error = true
        continue
      }
      var count = parseInt(res[1])
      if (res[1] == '') count = 1
      var type = 'd' + res[3]
      if (known_types.indexOf(type) == -1) {
        ret.error = true
        continue
      }
      while (count--) ret.set.push(type)
      if (res[5] && res[6]) {
        if (res[5] == '+') ret.constant += parseInt(res[6])
        else ret.constant -= parseInt(res[6])
      }
    }
    while ((res = dr1.exec(no[1]))) {
      ret.result.push(parseInt(res[2]))
    }
    return ret
  }

  function notation_getter() {
    return parse_notation('d20')
  }

  function after_roll(notation, result) {
    // if (result.length > 1) {
    //   diceResult.defaultValue = result.reduce((acc, val) => {
    //     return acc + val
    //   })
    // } else {
    //   diceResult.defaultValue = result[0]
    // }
  }

  box.bind_mouse(id('slide'), notation_getter, before_roll, after_roll)
  box.bind_throw(id('throw'), notation_getter, before_roll, after_roll)
}

dice_initialize(document['body'])
