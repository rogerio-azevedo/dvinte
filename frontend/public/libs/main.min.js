'use strict'

function dice_initialize(container) {
  var canvas = $t.id('canvas')
  canvas.style.width = window.innerWidth - 1 + 'px'
  canvas.style.height = window.innerHeight - 1 + 'px'

  var diceResult = $t.id('dices')
  var set = $t.id('set')
  on_set_change()

  $t.dice.use_true_random = false

  function on_set_change(ev) {}
  $t.bind(set, 'keyup', on_set_change)
  $t.bind(set, 'mousedown', function (ev) {
    ev.stopPropagation()
  })
  $t.bind(set, 'mouseup', function (ev) {
    ev.stopPropagation()
  })
  $t.bind(set, 'focus', function (ev) {
    $t.set(container, { class: '' })
  })
  $t.bind(set, 'blur', function (ev) {
    $t.set(container, { class: 'noselect' })
  })

  $t.bind($t.id('clear'), ['mouseup', 'touchend'], function (ev) {
    ev.stopPropagation()
    set.value = '0'
    on_set_change()
  })

  var box = new $t.dice.dice_box(canvas, { w: 500, h: 300 })

  $t.bind(window, 'resize', function () {
    canvas.style.width = window.innerWidth - 1 + 'px'
    canvas.style.height = window.innerHeight - 1 + 'px'
    box.reinit(canvas, { w: 500, h: 300 })
  })

  function before_roll(vectors, notation, callback) {
    // do here rpc call or whatever to get your own result of throw.
    // then callback with array of your result, example:
    // callback([2, 2, 2, 2]); // for 4d6 where all dice values are 2.
    callback()
  }

  function notation_getter() {
    return $t.dice.parse_notation(set.value)
  }

  function after_roll(notation, result) {
    if (result.length > 1) {
      diceResult.defaultValue = result.reduce((acc, val) => {
        return acc + val
      })
    } else {
      diceResult.defaultValue = result[0]
    }
  }

  box.bind_mouse($t.id('slide'), notation_getter, before_roll, after_roll)
  box.bind_throw($t.id('throw'), notation_getter, before_roll, after_roll)
}

dice_initialize(document['body'])
